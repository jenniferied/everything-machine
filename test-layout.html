<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout Test - Typing Animation Debugging</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #d1d5db;
            padding: 20px;
        }
        
        .test-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .test-header {
            background-color: #0c1424;
            border: 1px solid #374151;
            border-radius: 0.25rem;
            padding: 1.5rem;
            margin-bottom: 20px;
        }
        
        .test-header h1 {
            color: #4ade80;
            margin-bottom: 0.5rem;
        }
        
        .test-status {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }
        
        .test-status.waiting {
            background-color: #374151;
            color: #9ca3af;
        }
        
        .test-status.running {
            background-color: #1e3a5f;
            color: #60a5fa;
        }
        
        .test-status.complete {
            background-color: #0c2a1e;
            color: #4ade80;
        }
        
        .test-status.error {
            background-color: #5f1a1a;
            color: #f87171;
        }
        
        .iframe-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 2px solid #374151;
            border-radius: 0.25rem;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        #test-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .results-container {
            background-color: #0c1424;
            border: 1px solid #374151;
            border-radius: 0.25rem;
            padding: 1.5rem;
        }
        
        .results-container h2 {
            color: #4ade80;
            margin-bottom: 1rem;
        }
        
        .summary-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }
        
        .summary-table th,
        .summary-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #374151;
        }
        
        .summary-table th {
            background-color: #1f2937;
            color: #4ade80;
            font-weight: bold;
        }
        
        .summary-table tr:hover {
            background-color: #1f2937;
        }
        
        .issue-item {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border-left: 3px solid #f87171;
            background-color: #2a1a1a;
            border-radius: 0.25rem;
        }
        
        .issue-item.pass {
            border-left-color: #4ade80;
            background-color: #1a2a1a;
        }
        
        .issue-type {
            font-weight: bold;
            color: #f87171;
        }
        
        .issue-item.pass .issue-type {
            color: #4ade80;
        }
        
        .issue-details {
            margin-top: 0.25rem;
            font-size: 0.875rem;
            color: #9ca3af;
        }
        
        .download-btn {
            background-color: #4ade80;
            color: #111;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-weight: bold;
            margin-top: 1rem;
            transition: background-color 0.2s;
        }
        
        .download-btn:hover {
            background-color: #22c55e;
        }
        
        .log-output {
            background-color: #111;
            border: 1px solid #374151;
            border-radius: 0.25rem;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            margin-top: 1rem;
        }
        
        .log-entry {
            margin-bottom: 0.25rem;
        }
        
        .log-entry.info {
            color: #9ca3af;
        }
        
        .log-entry.success {
            color: #4ade80;
        }
        
        .log-entry.error {
            color: #f87171;
        }
        
        .log-entry.warning {
            color: #fbbf24;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>Layout Test - Typing Animation Debugging</h1>
            <div id="test-status" class="test-status waiting">Waiting to start...</div>
        </div>
        
        <div class="iframe-container">
            <iframe id="test-iframe" src="index.html"></iframe>
        </div>
        
        <div class="results-container">
            <h2>Test Results</h2>
            <div id="summary-container"></div>
            <div id="issues-container"></div>
            <button id="download-btn" class="download-btn" style="display: none;">Download JSON Results</button>
            <div class="log-output" id="log-output"></div>
        </div>
    </div>

    <script>
        class LayoutTest {
            constructor() {
                this.results = {
                    testRun: new Date().toISOString(),
                    baseline: null,
                    duringAnimation: [],
                    final: null,
                    issues: [],
                    summary: {
                        totalIssues: 0,
                        bubblesMovedUp: 0,
                        scrollJumps: 0,
                        repackingDetected: false,
                        bubblesNotMovingDown: 0
                    }
                };
                this.baselinePositions = new Map();
                this.monitorInterval = null;
                this.iframe = null;
                this.iframeDoc = null;
                this.iframeWindow = null;
                this.mutationObserver = null;
                this.animationComplete = false;
                this.titleBubble = null;
                this.titleBubbleBaselineHeight = 0;
                this.lastCharacterCount = 0;
                this.monitoringActive = false;
            }
            
            log(message, type = 'info') {
                const logOutput = document.getElementById('log-output');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logOutput.appendChild(entry);
                logOutput.scrollTop = logOutput.scrollHeight;
                
                // Also log to console with colors
                const styles = {
                    info: 'color: #9ca3af',
                    success: 'color: #4ade80',
                    error: 'color: #f87171',
                    warning: 'color: #fbbf24'
                };
                console.log(`%c[TEST] ${message}`, styles[type] || '');
            }
            
            updateStatus(status, text) {
                const statusEl = document.getElementById('test-status');
                statusEl.className = `test-status ${status}`;
                statusEl.textContent = text;
            }
            
            async run() {
                try {
                    this.updateStatus('running', 'Loading page...');
                    this.log('Starting layout test...', 'info');
                    
                    // 1. Load page in iframe
                    this.iframe = document.getElementById('test-iframe');
                    
                    await new Promise((resolve, reject) => {
                        this.iframe.onload = () => {
                            try {
                                this.iframeDoc = this.iframe.contentDocument || this.iframe.contentWindow.document;
                                this.iframeWindow = this.iframe.contentWindow;
                                
                                if (!this.iframeDoc) {
                                    throw new Error('Cannot access iframe document (same-origin required)');
                                }
                                
                                this.log('Page loaded successfully', 'success');
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        
                        this.iframe.onerror = () => {
                            reject(new Error('Failed to load iframe'));
                        };
                        
                        // If already loaded
                        if (this.iframe.contentDocument && this.iframe.contentDocument.readyState === 'complete') {
                            this.iframeDoc = this.iframe.contentDocument;
                            this.iframeWindow = this.iframe.contentWindow;
                            resolve();
                        }
                    });
                    
                    // 2. Wait for DOM ready
                    await this.waitForDOMReady();
                    
                    // 3. Navigate to logbook
                    this.log('Navigating to logbook page...', 'info');
                    this.navigateToLogbook();
                    
                    // 4. Wait for entries loaded
                    this.log('Waiting for journal entries to load...', 'info');
                    await this.waitForEntriesLoaded();
                    
                    // 5. Measure baseline positions
                    this.log('Measuring baseline positions...', 'info');
                    this.measureBaseline();
                    
                    // 6. Start monitoring (MutationObserver + interval)
                    this.log('Starting animation monitoring...', 'info');
                    this.startMonitoring();
                    
                    // 7. Wait for animation to complete
                    this.log('Waiting for typing animation to complete...', 'info');
                    await this.waitForAnimationComplete();
                    
                    // 8. Stop monitoring
                    this.stopMonitoring();
                    
                    // 9. Measure final positions
                    this.log('Measuring final positions...', 'info');
                    this.measureFinal();
                    
                    // 10. Analyze and output results
                    this.log('Analyzing results...', 'info');
                    this.analyzeResults();
                    
                    this.updateStatus('complete', 'Test complete!');
                    this.log('Test completed successfully', 'success');
                    this.displayResults();
                    
                } catch (error) {
                    this.updateStatus('error', `Error: ${error.message}`);
                    this.log(`Test failed: ${error.message}`, 'error');
                    console.error('Test error:', error);
                }
            }
            
            async waitForDOMReady() {
                return new Promise((resolve) => {
                    if (this.iframeDoc.readyState === 'complete') {
                        resolve();
                    } else {
                        this.iframeDoc.addEventListener('DOMContentLoaded', resolve, { once: true });
                    }
                });
            }
            
            navigateToLogbook() {
                // Call showPage function from iframe context
                if (this.iframeWindow.showPage) {
                    // Find the logbook menu item
                    const logbookItem = this.iframeDoc.querySelector('[data-page="logbook"]');
                    if (logbookItem) {
                        this.iframeWindow.showPage('logbook', logbookItem);
                    } else {
                        // Fallback: try to trigger navigation directly
                        const logbookButton = Array.from(this.iframeDoc.querySelectorAll('.dropdown-item')).find(
                            item => item.textContent.includes('Logbuch') || item.getAttribute('data-page') === 'logbook'
                        );
                        if (logbookButton) {
                            logbookButton.click();
                        }
                    }
                }
            }
            
            async waitForEntriesLoaded() {
                const maxWait = 10000; // 10 seconds
                const startTime = Date.now();
                const pollInterval = 100;
                
                return new Promise((resolve, reject) => {
                    const check = () => {
                        const grid = this.iframeDoc.querySelector('.content-grid');
                        const bubbles = grid ? grid.querySelectorAll('.content-bubble') : [];
                        
                        if (bubbles.length > 0) {
                            this.log(`Found ${bubbles.length} bubbles`, 'success');
                            resolve();
                        } else if (Date.now() - startTime > maxWait) {
                            reject(new Error('Timeout waiting for entries to load'));
                        } else {
                            setTimeout(check, pollInterval);
                        }
                    };
                    
                    check();
                });
            }
            
            measureBubblePositions() {
                const grid = this.iframeDoc.querySelector('.content-grid');
                if (!grid) return [];
                
                const bubbles = grid.querySelectorAll('.content-bubble');
                const logbookMain = this.iframeDoc.querySelector('.logbook-main');
                const scrollTop = logbookMain ? logbookMain.scrollTop : 0;
                
                const positions = [];
                
                bubbles.forEach((bubble, index) => {
                    const rect = bubble.getBoundingClientRect();
                    const styles = this.iframeWindow.getComputedStyle(bubble);
                    
                    positions.push({
                        index: index,
                        top: rect.top,
                        left: rect.left,
                        width: rect.width,
                        height: rect.height,
                        gridRowStart: styles.gridRowStart,
                        gridRowEnd: styles.gridRowEnd,
                        gridColumnStart: styles.gridColumnStart,
                        gridColumnEnd: styles.gridColumnEnd
                    });
                });
                
                return {
                    bubbles: positions,
                    scroll: scrollTop,
                    timestamp: Date.now()
                };
            }
            
            measureBaseline() {
                const positions = this.measureBubblePositions();
                this.results.baseline = positions;
                
                // Store baseline positions in Map for quick lookup
                positions.bubbles.forEach(bubble => {
                    this.baselinePositions.set(bubble.index, bubble);
                });
                
                // Find title bubble and store its baseline height
                const titleElement = this.iframeDoc.querySelector('.journal-title');
                if (titleElement) {
                    this.titleBubble = titleElement.closest('.content-bubble');
                    if (this.titleBubble) {
                        this.titleBubbleBaselineHeight = this.titleBubble.offsetHeight;
                    }
                }
                
                this.log(`Baseline measured: ${positions.bubbles.length} bubbles, scroll: ${positions.scroll}px`, 'success');
            }
            
            measureFinal() {
                const positions = this.measureBubblePositions();
                this.results.final = positions;
                this.log(`Final positions measured: ${positions.bubbles.length} bubbles, scroll: ${positions.scroll}px`, 'success');
            }
            
            startMonitoring() {
                this.monitoringActive = true;
                this.lastCharacterCount = 0;
                
                // Find title text element
                const titleText = this.iframeDoc.querySelector('.journal-title-text');
                
                if (titleText) {
                    // Use MutationObserver to detect character additions
                    this.mutationObserver = new MutationObserver((mutations) => {
                        let textChanged = false;
                        mutations.forEach((mutation) => {
                            if (mutation.type === 'childList' || mutation.type === 'characterData') {
                                textChanged = true;
                            }
                        });
                        
                        if (textChanged) {
                            const currentLength = titleText.textContent.length;
                            if (currentLength > this.lastCharacterCount) {
                                this.lastCharacterCount = currentLength;
                                this.measureDuringAnimation(currentLength);
                            }
                        }
                    });
                    
                    this.mutationObserver.observe(titleText, {
                        childList: true,
                        characterData: true,
                        subtree: true
                    });
                    
                    this.log('MutationObserver started on .journal-title-text', 'success');
                } else {
                    this.log('Warning: .journal-title-text not found, using interval only', 'warning');
                }
                
                // Also use interval as backup (every 100ms)
                this.monitorInterval = setInterval(() => {
                    if (!this.monitoringActive) return;
                    
                    const titleText = this.iframeDoc.querySelector('.journal-title-text');
                    if (titleText) {
                        const currentLength = titleText.textContent.length;
                        if (currentLength > this.lastCharacterCount) {
                            this.lastCharacterCount = currentLength;
                            this.measureDuringAnimation(currentLength);
                        }
                    }
                    
                    // Check if animation is complete (caret has blink class)
                    const caret = this.iframeDoc.querySelector('.journal-title-caret.blink');
                    if (caret && !this.animationComplete) {
                        this.animationComplete = true;
                        this.log('Animation complete detected (caret blinking)', 'success');
                    }
                }, 100);
            }
            
            measureDuringAnimation(characterIndex) {
                const positions = this.measureBubblePositions();
                const issues = this.detectIssues(positions, this.results.baseline);
                
                this.results.duringAnimation.push({
                    timestamp: Date.now(),
                    characterIndex: characterIndex,
                    bubbles: positions.bubbles,
                    scroll: positions.scroll,
                    issues: issues
                });
                
                if (issues.length > 0) {
                    this.log(`Character ${characterIndex}: ${issues.length} issue(s) detected`, 'error');
                    issues.forEach(issue => {
                        this.log(`  - ${issue.message}`, 'error');
                    });
                }
            }
            
            detectIssues(currentPositions, baselinePositions) {
                const issues = [];
                const thresholdUp = 5; // px
                const thresholdScroll = 10; // px
                const thresholdRepack = 50; // px
                
                // Check scroll position
                const scrollDiff = Math.abs(currentPositions.scroll - baselinePositions.scroll);
                if (scrollDiff > thresholdScroll) {
                    issues.push({
                        type: 'scroll_jump',
                        message: `Scroll position jumped by ${scrollDiff.toFixed(1)}px (baseline: ${baselinePositions.scroll}px, current: ${currentPositions.scroll}px)`,
                        deltaY: currentPositions.scroll - baselinePositions.scroll
                    });
                }
                
                // Check each bubble
                currentPositions.bubbles.forEach((currentBubble) => {
                    const baselineBubble = this.baselinePositions.get(currentBubble.index);
                    if (!baselineBubble) return;
                    
                    // Check if bubble moved up (should stay fixed)
                    const deltaY = currentBubble.top - baselineBubble.top;
                    if (deltaY < -thresholdUp) {
                        issues.push({
                            type: 'bubble_moved_up',
                            bubbleIndex: currentBubble.index,
                            message: `Bubble ${currentBubble.index} moved UP by ${Math.abs(deltaY).toFixed(1)}px (should stay fixed)`,
                            deltaY: deltaY,
                            baselineTop: baselineBubble.top,
                            currentTop: currentBubble.top
                        });
                    }
                    
                    // Check for repacking (left position changed significantly)
                    const deltaX = Math.abs(currentBubble.left - baselineBubble.left);
                    if (deltaX > thresholdRepack) {
                        issues.push({
                            type: 'repacking',
                            bubbleIndex: currentBubble.index,
                            message: `Bubble ${currentBubble.index} changed column (left position changed by ${deltaX.toFixed(1)}px)`,
                            deltaX: deltaX,
                            baselineLeft: baselineBubble.left,
                            currentLeft: currentBubble.left
                        });
                    }
                });
                
                // Check if title bubble grew but bubbles below didn't move down
                if (this.titleBubble) {
                    const currentTitleHeight = this.titleBubble.offsetHeight;
                    const titleHeightDiff = currentTitleHeight - this.titleBubbleBaselineHeight;
                    
                    if (titleHeightDiff > 10) { // Title grew significantly
                        // Find bubbles that should be below the title bubble
                        const titleBubbleIndex = Array.from(this.titleBubble.parentElement.children).indexOf(this.titleBubble);
                        const bubblesBelow = currentPositions.bubbles.filter(b => b.index > titleBubbleIndex);
                        
                        bubblesBelow.forEach(bubble => {
                            const baselineBubble = this.baselinePositions.get(bubble.index);
                            if (baselineBubble) {
                                // Bubble should have moved down by at least the title growth
                                const expectedDeltaY = titleHeightDiff;
                                const actualDeltaY = bubble.top - baselineBubble.top;
                                
                                if (actualDeltaY < expectedDeltaY - thresholdUp) {
                                    issues.push({
                                        type: 'bubble_not_moving_down',
                                        bubbleIndex: bubble.index,
                                        message: `Bubble ${bubble.index} should move DOWN by ~${expectedDeltaY.toFixed(1)}px (title grew) but only moved by ${actualDeltaY.toFixed(1)}px`,
                                        expectedDeltaY: expectedDeltaY,
                                        actualDeltaY: actualDeltaY
                                    });
                                }
                            }
                        });
                    }
                }
                
                return issues;
            }
            
            async waitForAnimationComplete() {
                const maxWait = 30000; // 30 seconds
                const startTime = Date.now();
                const pollInterval = 200;
                
                return new Promise((resolve) => {
                    const check = () => {
                        if (this.animationComplete) {
                            resolve();
                        } else if (Date.now() - startTime > maxWait) {
                            this.log('Timeout waiting for animation (continuing anyway)', 'warning');
                            this.animationComplete = true;
                            resolve();
                        } else {
                            setTimeout(check, pollInterval);
                        }
                    };
                    
                    check();
                });
            }
            
            stopMonitoring() {
                this.monitoringActive = false;
                
                if (this.mutationObserver) {
                    this.mutationObserver.disconnect();
                    this.mutationObserver = null;
                }
                
                if (this.monitorInterval) {
                    clearInterval(this.monitorInterval);
                    this.monitorInterval = null;
                }
                
                this.log('Monitoring stopped', 'info');
            }
            
            analyzeResults() {
                // Collect all issues from duringAnimation
                this.results.duringAnimation.forEach(measurement => {
                    if (measurement.issues && measurement.issues.length > 0) {
                        this.results.issues.push(...measurement.issues);
                    }
                });
                
                // Also check final state
                if (this.results.final && this.results.baseline) {
                    const finalIssues = this.detectIssues(this.results.final, this.results.baseline);
                    this.results.issues.push(...finalIssues);
                }
                
                // Update summary
                this.results.summary.totalIssues = this.results.issues.length;
                this.results.summary.bubblesMovedUp = this.results.issues.filter(i => i.type === 'bubble_moved_up').length;
                this.results.summary.scrollJumps = this.results.issues.filter(i => i.type === 'scroll_jump').length;
                this.results.summary.repackingDetected = this.results.issues.some(i => i.type === 'repacking');
                this.results.summary.bubblesNotMovingDown = this.results.issues.filter(i => i.type === 'bubble_not_moving_down').length;
                
                this.log(`Analysis complete: ${this.results.summary.totalIssues} total issues`, 
                    this.results.summary.totalIssues > 0 ? 'error' : 'success');
            }
            
            displayResults() {
                const summaryContainer = document.getElementById('summary-container');
                const issuesContainer = document.getElementById('issues-container');
                const downloadBtn = document.getElementById('download-btn');
                
                // Summary table
                const summary = this.results.summary;
                summaryContainer.innerHTML = `
                    <table class="summary-table">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Total Issues</td>
                                <td>${summary.totalIssues}</td>
                            </tr>
                            <tr>
                                <td>Bubbles Moved Up</td>
                                <td>${summary.bubblesMovedUp}</td>
                            </tr>
                            <tr>
                                <td>Scroll Jumps</td>
                                <td>${summary.scrollJumps}</td>
                            </tr>
                            <tr>
                                <td>Repacking Detected</td>
                                <td>${summary.repackingDetected ? 'Yes' : 'No'}</td>
                            </tr>
                            <tr>
                                <td>Bubbles Not Moving Down</td>
                                <td>${summary.bubblesNotMovingDown}</td>
                            </tr>
                            <tr>
                                <td>Measurements During Animation</td>
                                <td>${this.results.duringAnimation.length}</td>
                            </tr>
                        </tbody>
                    </table>
                `;
                
                // Issues list
                if (this.results.issues.length > 0) {
                    issuesContainer.innerHTML = '<h3 style="color: #f87171; margin-top: 1.5rem; margin-bottom: 1rem;">Detected Issues</h3>';
                    this.results.issues.forEach((issue, index) => {
                        const issueEl = document.createElement('div');
                        issueEl.className = 'issue-item';
                        issueEl.innerHTML = `
                            <div class="issue-type">[${issue.type}]</div>
                            <div class="issue-details">${issue.message}</div>
                        `;
                        issuesContainer.appendChild(issueEl);
                    });
                } else {
                    issuesContainer.innerHTML = '<div class="issue-item pass"><div class="issue-type">âœ“ No issues detected!</div></div>';
                }
                
                // Show download button
                downloadBtn.style.display = 'block';
                downloadBtn.onclick = () => {
                    const json = JSON.stringify(this.results, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `layout-test-${this.results.testRun.replace(/[:.]/g, '-')}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                };
            }
        }
        
        // Start test when page loads
        window.addEventListener('load', () => {
            const test = new LayoutTest();
            test.run();
        });
    </script>
</body>
</html>

