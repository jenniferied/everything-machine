# Everything Machine - Cursor AI Rules

## Code Architecture Principles

### SOLID Principles (MANDATORY)
- **Single Responsibility**: Each class/module has ONE clear purpose
- **Open/Closed**: Extend through composition, not modification
- **Liskov Substitution**: Implementations must be interchangeable
- **Interface Segregation**: Minimal, focused interfaces
- **Dependency Inversion**: Depend on abstractions (EventBus), not concrete classes

### Module Structure
- One class per file (except small utilities)
- ES6 modules exclusively (import/export)
- Dependency injection via constructors
- EventBus for cross-component communication
- NO global variables (except the app instance)
- Every component has a `dispose()` method for cleanup

### File Naming Conventions
- **Classes**: PascalCase (e.g., `MusicPlayer.js`, `PlaybackController.js`)
- **Utilities**: camelCase (e.g., `timeFormatter.js`, `dateUtils.js`)
- **Descriptive names**: `PlayerUI.js` not `UI.js`, `JournalLoader.js` not `Loader.js`

### Event Naming Convention
- **Format**: `category:action` (lowercase, colon separator)
- **Examples**: 
  - `player:play`, `player:pause`, `player:trackChanged`
  - `journal:loaded`, `journal:entrySelected`
  - `nav:pageChanged`, `nav:dropdownToggled`
- **Consistency**: Use past tense for completed actions (`loaded`, `changed`)

## Code Quality Standards

### Documentation
- JSDoc comments for public methods
- Explain WHY, not WHAT (code should be self-explanatory)
- Document parameter types and return values
- Include usage examples for complex APIs

### Error Handling
- Always handle promise rejections
- Log errors with context: `console.error('[ComponentName] Error message:', error)`
- Provide fallbacks for non-critical failures
- Never fail silently

### Performance
- Debounce expensive operations (layout calculations, DOM updates)
- Use `requestAnimationFrame` for visual updates
- Lazy load heavy dependencies
- Dispose resources properly (event listeners, timers, observers)

## Commit Strategy (CRITICAL)

### When to Commit
✅ **COMMIT WHEN**:
- Feature works and is tested manually in browser
- All console errors are resolved
- Feature integration doesn't break existing functionality
- You have verified the changes visually

❌ **DO NOT COMMIT WHEN**:
- You "think" it works but haven't tested
- There are console errors
- You haven't opened the browser yet
- Code is incomplete or commented out

### Testing Before Commit Checklist
1. Open browser DevTools (Console + Network tabs)
2. Test the feature manually (click buttons, navigate, etc.)
3. Check console for errors or warnings
4. Verify no regressions in related features
5. Check EventBus debug logs (if enabled)
6. Test on both desktop and mobile viewport
7. **THEN** commit with descriptive message

### Commit Message Format
```
[Component] Brief description

- Detailed change 1
- Detailed change 2

Tested: [What you tested manually]
```

Example:
```
[Audio] Implement SOLID music player system

- Create Playlist, PlaybackController, PlayerUI modules
- Wire up EventBus communication
- Migrate marquee animation from scripts.js

Tested: Play/pause, next/prev, playlist selection, time display
```

## Development Workflow

### Building New Features
1. **Plan**: Identify responsibilities and dependencies
2. **Create**: Build module with clear interface
3. **Test**: Test in isolation first
4. **Integrate**: Wire into app.js with EventBus
5. **Verify**: Test integration and cross-feature behavior
6. **Document**: Update IMPLEMENTATION.md
7. **Commit**: Follow commit checklist above

### Refactoring Existing Code
1. **Understand**: Read and understand current implementation
2. **Extract**: Identify distinct responsibilities
3. **Create**: Build new modules with SOLID principles
4. **Parallel**: Keep old code working while building new
5. **Switch**: Replace old with new, test thoroughly
6. **Remove**: Delete old code only after verification
7. **Document**: Update documentation

### Debugging
- Use browser DevTools, not console.log spam
- Enable EventBus debug mode: `eventBus.setDebugMode(true)`
- Check Network tab for failed fetches
- Use breakpoints, not alerts
- Check memory leaks with Performance tab

## Project-Specific Guidelines

### EventBus Usage
```javascript
// Emit events for state changes
this.eventBus.emit('player:trackChanged', { trackIndex, track });

// Listen to events from other components
this.eventBus.on('nav:pageChanged', (pageId) => {
  // React to page change
});

// Always dispose listeners
dispose() {
  this.eventBus.off('nav:pageChanged', this.handlePageChange);
}
```

### DOM Element Injection
```javascript
// GOOD: Inject DOM elements
constructor(containerElement, eventBus) {
  this.container = containerElement;
  this.eventBus = eventBus;
}

// BAD: Query inside constructor
constructor(eventBus) {
  this.container = document.getElementById('player'); // Hard-coded coupling
}
```

### Progressive Enhancement
- Always provide fallbacks
- Detect capabilities before using features
- Graceful degradation for unsupported browsers
- Mobile-first responsive design

### Audio System Specifics
- Use EventBus for playback state changes
- Time updates throttled to avoid performance issues
- Playlist data is immutable
- UI updates are reactive to playback events

### Journal System Specifics
- Markdown parsing is synchronous
- Rendering is asynchronous (waits for images)
- Grid layout optimizes on resize (debounced)
- Typing animation uses RAF for smooth updates

### Navigation System Specifics
- localStorage for persistence
- Emit events for page changes
- Lazy load journal only when needed
- Dropdowns are mutually exclusive

## Code Smells to Avoid

❌ **Global Variables**
```javascript
let currentTrack = 0; // BAD
```

❌ **Direct DOM Queries in Methods**
```javascript
play() {
  document.getElementById('audio').play(); // BAD
}
```

❌ **Mixed Concerns**
```javascript
loadTrack(index) {
  // Load audio
  // Update UI
  // Save to localStorage
  // Send analytics
  // BAD - too many responsibilities
}
```

❌ **Magic Numbers/Strings**
```javascript
if (type === 'song') // BAD
const SONG_TYPE = 'song'; // GOOD
```

## AI Agent Instructions

When asked to implement features:
1. Ask clarifying questions if requirements are ambiguous
2. Propose SOLID architecture before coding
3. Show interface/API design first
4. Implement with dependency injection
5. Include dispose methods
6. Emit relevant events
7. Test manually before marking done

When asked to debug:
1. Ask for browser console output
2. Check EventBus logs
3. Verify DOM elements exist
4. Check network requests
5. Propose hypothesis before making changes

When asked to refactor:
1. Identify SOLID violations
2. Propose module breakdown
3. Keep old code working during transition
4. Test each module independently
5. Remove old code only after verification

## Resources

- **SOLID Principles**: https://en.wikipedia.org/wiki/SOLID
- **EventBus Pattern**: Pub/sub for loose coupling
- **Dependency Injection**: Constructor injection preferred
- **Project Documentation**: See IMPLEMENTATION.md for architecture details

---

# Artistic Research Guidelines

**WICHTIG**: Diese Richtlinien gelten beim Bearbeiten von Markdown-Dateien im `journal/`-Ordner und anderen inhaltlichen Dokumenten.

## Forschungsrahmen (Quick Reference)

Dieses Projekt untersucht: **Wie verändert der Einsatz generativer KI-Werkzeuge kreative Arbeitsprozesse?**

Vollständiger Rahmen: Siehe [FORSCHUNGSRAHMEN.md](FORSCHUNGSRAHMEN.md)
Referenzarbeiten: Siehe [referenzen.md](referenzen.md)

## Journal-Eintrag Struktur (EMPFOHLEN)

Beim Schreiben oder Bearbeiten von Journal-Einträgen, erinnere an diese Struktur:

```markdown
# [Titel des Experiments/der Session]

**[Datum]**

## Intention
Was wollte ich erreichen? Welche Frage habe ich verfolgt?

## Prozess
Was habe ich konkret getan? (Screenshots, Prompts, Einstellungen)

## Ergebnis
Was ist passiert? Erfolgreich oder nicht?

## Reflexion ← KRITISCH FÜR AR
- Was habe ich gelernt?
- Was hat mich überrascht?
- Wie verändert das meinen Workflow?
- Welche neuen Fragen entstehen?

## Nächste Schritte
Was mache ich als nächstes?
```

## AR Reflexions-Prompts

Wenn ein Journal-Eintrag geschrieben wird, stelle diese Fragen:

### Workflow-Transformation
- [ ] Hat sich mein Arbeitsablauf durch dieses Experiment verändert?
- [ ] Welche Schritte waren neu? Welche sind weggefallen?
- [ ] Wie schnell kam ich zu Ergebnissen im Vergleich zu traditionellen Methoden?

### Autorschaft & Kollaboration
- [ ] Wer hat dieses Ergebnis "gemacht" – ich oder die KI?
- [ ] Wie war das Verhältnis von Kontrolle vs. Emergenz?
- [ ] War das Ergebnis vorhersehbar oder überraschend?

### Scheitern als Erkenntnis
- [ ] Was hat NICHT funktioniert und warum?
- [ ] Was verrät dieser Fehler über die Technologie?
- [ ] Kann ich das Scheitern dokumentieren? (Screenshots!)

### Verbindung zum Ganzen
- [ ] Wie passt dieses Experiment zu meinen Forschungsfragen?
- [ ] Gibt es Verbindungen zu den Referenzarbeiten?
- [ ] Entwickelt sich eine eigene ästhetische Sprache?

## Qualitätskriterien für AR Journal-Einträge

✅ **GUT**:
- Zeigt den Prozess, nicht nur das Ergebnis
- Dokumentiert Fehlschläge und Umwege
- Enthält persönliche Reflexion ("Ich war überrascht, dass...")
- Verbindet konkrete Erfahrung mit größeren Fragen
- Enthält visuelles Material (Screenshots, generierte Bilder)

❌ **VERMEIDEN**:
- Nur Tutorial-artige Beschreibung ("Klicke hier, dann dort")
- Nur Ergebnisse ohne Kontext
- Fehlende Reflexion ("Es hat funktioniert" – WARUM? WAS BEDEUTET DAS?)
- Rein technische Beschreibung ohne persönliche Perspektive

## Reminder für AI-Assistenten

Wenn die Nutzerin einen Journal-Eintrag schreibt oder bearbeitet:

1. **Frage nach der Reflexion**: "Was hat dich überrascht?" / "Wie hat das deinen Workflow verändert?"
2. **Erinnere an Fehlerdokumentation**: "Kannst du auch zeigen, was nicht funktioniert hat?"
3. **Verbinde zum Forschungsrahmen**: "Wie passt das zu deiner Frage nach Workflow-Transformation?"
4. **Schlage Referenzen vor**: "Das erinnert an Anna Ridlers Arbeit mit Datensätzen..."

## Zitierformat für Referenzen

Wenn auf Referenzarbeiten verwiesen wird:

```markdown
Ähnlich wie in [TroublingGAN](referenzen.md#troublinggan) zeigt sich hier, dass...

Vgl. Anna Ridlers Konzept des "Dataset as Art" – die Sammlung der Referenzbilder ist selbst Teil der künstlerischen Arbeit.
```

## Sprachliche Konventionen

- **Ich-Perspektive**: "Ich habe festgestellt..." statt "Man kann feststellen..."
- **Prozessorientiert**: "Beim Experimentieren zeigte sich..." statt "Das Ergebnis ist..."
- **Ehrlich über Unsicherheit**: "Ich bin mir nicht sicher, ob..." ist völlig okay
- **Fragen stellen**: Ein Eintrag darf mit offenen Fragen enden

---

# Academic Materials (academic/)

The `academic/` folder contains MA thesis materials for the Artistic Research course. This folder is NOT deployed to GitHub Pages.

## Folder Purpose

| Folder | Purpose |
|--------|---------|
| `Abgabe.md` | **CRITICAL**: Submission requirements defining final output structure |
| `Exposé_*.pdf` | Project exposé document |
| `artistic-research/` | Literature sources for bibliography |
| `examples/` | Lesson material examples |
| `lesson-material/` | Class materials and slides |
| `thilos-straightA-submission/` | **IMPORTANT**: A-grade submission example with similar theme |

## When Working on Academic Content

1. **Always reference Abgabe.md** for submission requirements
2. **Use Thilo's submission** as a structural reference (not content)
3. **Literature goes in artistic-research/** folder
4. **Follow APA format** for citations
5. **Paper structure**: Einleitung → Stand der Forschung → Methodologie → Meine Forschung → Diskussion

